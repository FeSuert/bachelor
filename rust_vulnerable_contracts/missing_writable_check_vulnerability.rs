use anchor_lang::prelude::*;
use solana_program::program_error::ProgramError;
use anchor_lang::solana_program::account_info::next_account_info;
use std::ops::Deref;

declare_id!("F1234567890123456789012345678901234567890");

#[program]
pub mod manual_writable_check {
    use super::*;

    // A function that simulates manual account iteration and writability check
    pub fn update_data(ctx: Context<ManualCheck>, data: u64) -> Result<()> {
        // Simulating manual account iteration
        let accounts_iter = &mut ctx.remaining_accounts.iter();
        let hello_state_account = next_account_info(accounts_iter)?;

        // Manually checking if the account is writable
        if !hello_state_account.is_writable {
            return Err(ProgramError::InvalidAccountData);
        }

        let mut data_account = DataAccount::try_from_slice(&hello_state_account.data.borrow())?;
        data_account.data = data;
        data_account.serialize(&mut *hello_state_account.data.borrow_mut())?;

        Ok(())
    }
}

#[derive(Accounts)]
pub struct ManualCheck<'info> {
    #[account(mut)]
    pub remaining_accounts: AccountInfo<'info>,
}

#[account]
pub struct DataAccount {
    pub data: u64,
}

// Recommendation:
// let hello_state_account = next_account_info(accounts_iter)?;
// if !hello_state_account.is_writable {
//     return Err(ProgramError::InvalidAccountData);
// }